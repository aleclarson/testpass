// @flow

declare type TestFn = (test: RunningTest) => ?Promise<void>
declare type CatchFn = (error: Error) => ?boolean
declare type MatchFn = (path: string, name: string) => ?boolean

module.exports = (require('./index'): Exports)

declare class Exports {
  beforeAll(fn: () => void): void;
  beforeEach(fn: () => void): void;
  afterEach(fn: () => void): void;
  afterAll(fn: () => void): void;
  filter(pattern: string | RegExp): void;
  group(id: string, fn: () => void): void;
  group(fn: () => void): void;
  fgroup(id: string, fn: () => void): void;
  fgroup(fn: () => void): void;
  xgroup(id: string, fn: () => void): void;
  xgroup(fn: () => void): void;
  test(id: string, fn: TestFn): Test;
  test(fn: TestFn): Test;
  ftest(id: string, fn: TestFn): Test;
  ftest(fn: TestFn): Test;
  xtest(id: string, fn: TestFn): Test;
  xtest(fn: TestFn): Test;
  watchDir(dir: string): void;
  findTests(dir: string, pattern: string | RegExp | MatchFn): void;
  reloadTests(path: string): boolean;
  reloadAllTests(): void;
  removeTests(path: string): boolean;
  startTests(options: RunnerOptions): Promise<Object>;
  stopTests(): Promise<void>;
}

declare class Test {
  id: string;
  fn: TestFn;
  line: number;
  catch(value: any): void;
}

declare type RunnerOptions = {
  verbose: ?boolean,
}

declare class Runner {
  promise: ?Promise<Results>;
  stopped: boolean;
  finished: boolean;
  start(): Promise<Results>;
  stop(): void;
}

declare type Results = {
  files: any[],
  testCount: number,
  passCount: number,
  failCount: number,
}

declare class RunningTest {
  eq(result: any, expected: any): void;
  ne(result: any, expected: any): void;
  assert(cond: ?boolean): void;
  fail(message: string): void;
}
